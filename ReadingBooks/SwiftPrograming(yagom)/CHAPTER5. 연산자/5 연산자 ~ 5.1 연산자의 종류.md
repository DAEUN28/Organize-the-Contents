# 5 연산자

스위프트의 연산자는 특정한 문자로 표현한 함수라 할 수 있다. 따라서 특정 연산자의 역할을 프로그래머의 의도대로 변경할 수도 있다.

*스위프트에서 추가된 개념이거나 독특한 특정이 있는 연산자만 기재



# 5.1 연산자의 종류

#### 5.1.3 참조 비교 연산자

A **===** B : A와 B가 참조 타입일 때 A와 B가 같은 인스턴스를 가리키는지 비교하여 불린 값을 반환한다.

A **!==** B : A와 B의 패턴이 매치되는지 확인하여 불린 값을 반환한다.

스위프트의 유일한 참조 타입인 클래스의 인스턴스에서만 참조 비교 연산자를 사용할 수 있다. 스위프트의 기본 데이터 타입은 모두 구조체로 구현되어 있기 때문에 값 타입이다. 그래서 클래스의 인스턴스인 경우에만 ===르ㅡㄹ 사용한다. 

#### 5.1.9 오버플로 연산자

기존 로그래밍 언어에서는 오버플로 또는 언더플로 가능성이 있는 연산에 대해서는 따로 오버플로에 대한 추가 알고리즘 및 로직 등을 설계하는 것이 일반적이었다. 스위프트는 기본 연산자를 통해 오버플로에 대비할 수 있도록 준비해두었다.

| 연산자               | 부호 | 설명                                |
| -------------------- | ---- | ----------------------------------- |
| 오버플로 더하기 연산 | &+   | 오버플로에 대비한 덧셈 연산을 한다. |
| 오버플로 빼기 연산   | &-   | 오버플로에 대비한 뺄셈 연산을 한다. |
| 오버플로 곱하기 연산 | &*   | 오버플로에 대비한 곱셈 연산을 한다. |

예를 들어 UInt8 타입은 8비트 정수 타입으로 부호가 없는 양의 정수만을 표현하기 때문에 0 아래로 내려가는 계산을 하면 런타임 오류가 발생한다. 그렇지만 오버플로 빼기 연산을 사용하면 오류 없이 오버플로 처리를 해준다. 그렇지만 오버플로에 대한 이해 없이 사용한다면 엉뚱한 값을 구할 수도 있다. 

```swift
var unsignedInteger: UInt8 = 0
let errorUnderflowResult : UInt8 = unsignedInteger - 1 //런타임 오류
let underflowedValue: UInt8 = unsignedInteger &- 1     //255

unsignedInteger = UInt8.max
let errorOverflowResult: UInt8 = unsignedInteger + 1   //런타임오류
let overflowedVale: UInt8 = unsignedInteger &+ 1		 	 //0
```

#### 5.1.10 기타 연산자

| 연산자                  | 부호   | 설명                                                         |
| ----------------------- | ------ | ------------------------------------------------------------ |
| nil 병합 연산자         | A ?? B | A가 nil이 아니면 A를 반환하고, A가 nil이면 B를 반환한다.     |
| 부호변경 연산자         | -A     | A(수)의 부호를 변경한다.                                     |
| 옵셔널 강제 추출 연산자 | O!     | O(옵셔널 개체)의 값을 강제로 추출한다.                       |
| 옵셔널 연산자           | V?     | V(옵셔널 값)를 안전하게 추출하거나, V(데이터 타입)가 옵셔널임을 표현한다 |

