# 13 클로저

**클로저** : 일정 기능을 하는 코드를 하나의 블록으로 모아놓은 것

클로저는 변수나 상수가 선언된 위치에서 참조를 획득하고 저장할 수 있다. 이를 변수나 상수의 클로징(잠금)이라고 하며 클로저는 여기서 착안된 이름이다. 클로저의 몇 가지 모양 중 하나가 함수이다. 

클로저는 세 가지 형태가 있다.

- 이름이 있으면서 어떤 값도 획득하지 않는 전역함수의 형태
- 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태
- 이름이 없고 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성한 형태

클로저를 다양하게 표현하는 방법에도 여러가지 형태가 있다.

- 클로저는 매개변수와 반환 값의 타입을 문맥을 통해 유추할 수 있기 때문에 매개변수와 반환 값의 타입을 생략할 수 있다.
- 클로저에 단 한줄의 표현만 들어있다면 암시적으로 이를 반환 값으로 취급한다.
- 축약된 전달인자 이름을 사용할 수 있다.
- 후행 클로저 문법을 사용할 수 있다. 

클로저 표현 방법은 클로저가 함수의 모습이 아닌 하나의 블록의 모습으로 표현될 수 있는 방법을 의미한다. 클로저 표현 방법은 클로저의 위치를 기준으로 크게 기본 클로저 표현과 후행 클로저 표현이 있다. 또, 각 표현 내에서 가독성을 해치지 않는 선에서 표현을 생략하거나 축약할 수 있는 방법이 있다. 



# 13.1 기본 클로저 

클로저 표현은 통상 아래 형식을 따른다.

```swift
{ (매개변수들) -> 반환타입 in
  	실행코드
}
```

클로저도 함수와 마찬가지로 입출력 매개변수를 사용할 수 있다. 매개변수 이름을 지정한다면 가변 매개변수 또한 사용 가능하다. 다만 클로저는 매개변수 기본값을 사용할 수 없다. 

기본 클로저 내용을 포함하여 앞으로 sorted(by: ) 메서드를 이용해 동일한 기능을 하는 코드를 간결하게 표현하는 방법을 알아보겠다. 스위프트 표준 라이브러리에는 배열의 값을 정렬하기 위해 구현한 sorted(by: )메서드가 있다. 이 메서드는 클로저를 통해 어떻게 정렬할 것인가에 대한 정보를 받아 처리하고 결괏값을 배열로 돌려준다. 기존의 배열은 변경하지 않고 정렬된 배열을 새로 생성하여 반환해준다. 다음은 sorted(by: ) 메서드의 정의이다. 

```swift
func sorted(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> [Element]
```

sorted(by: ) 메서드는 클로저를 전달인자로 받을 수 있다. 반환하는 Bool 값은 첫 번째 전달인자 값이 새로 생성되는 배열에서 두 번째 전달인자 값보다 먼저 배치되어야 하는지에 대한 결괏값이다. true를 반환하면 첫 번째 전달인자가 두 번째 전달인자보다 앞에 온다.  다음은 정렬에 사용될 이름 배열이다.

```swift
let names: [String] = ["wizplan", "eric", "yagom", "jenny"]
```

다음은 정렬을 위한 함수 전달이다.

```swift
func backwards(first: String, second: String) -> Bool {
  return first > second
}

let reversed = names.sorted(by: backwards)
```

first > seconde라는 반환 값을 받기 위해 너무 많은 표현을 사용했다. 이를 클로저 표현을 사용하면 조금 더 간결하게 표현할 수 있다. 

```swift
let reversed = names.sorted (by: { (first: String, second: String) -> Bool in
  return first > second
})
```

이렇게 프로그래밍 하면 sorted(by: ) 메서드로 전달되는 backward(first:second:) 함수가 어디에 있는지, 어떻게 구현되어 있는지 찾아다니지 않아도 된다. 물론, 반복해서 같은 기능을 사용하려면 함수로 구현해두는 것도 나쁘지 않다. 



# 13.2 후행 클로저

함수나 메서드의 마지막 전달인자로 위치하는 클로저는 함수나 메서드의 소괄호를 닫은 후 작성해도 된다. 클로저가 조금 길어지거나 가독성이 조금 떨어진다 싶으면 **후행 클로저** 기능을 사용하면 좋다. Xcode에서 자동완성 기능을 사용하면 후행 클로저로 유도한다. 단, 후행 클로저는 맨 마지막 전달인자로 전달되는 클로저에만 해당되므로 전달인자로 클로저 여러 개를 전달할 때는 맨 마지막 클로저만 후행 클로저로 사용할 수 있다. 또한 단 하나의 클로저만 전달인자로 전달하는 경우에는 소괄호를 생략 해줄 수도 있다. 

```swift
let reversed = names.sorted() { (first: String, second: String) -> Bool in
  return first > second
}

// sorted(by: ) 메서드의 소괄호까지 생략 가능하다. 
let reversed = names.sorted { (first: String, second: String) -> Bool in
  return first > second
}
```



# 13.3 클로저 표현 간소화

#### 13.3.1 문맥을 이용한 타입 유추

메서드의 전달이자로 전달하는 클로저는 메서드에서 요구하는 형태로 전달해야 한다. 즉, 매개변수의 타입이나 개수, 반환 타입 등이 같아야 전달인자로서 전달할 수 있다. 이를 다르게 말하면, 전달인자로 전달할 클로저는 이미 적합한 타입을 준수하고 있다고 유추할 수 있다. 문맥에 따라 적절히 타입을 유추할 수 있는 것이다. 그래서 전달인자로 전달하는 클로저를 구현할 때는 매개변수의 타입이나 반환 값의 타입을 굳이 표현해주지 않고 생략하더라도 문제가 없다. 

```swift
let reversed = names.sorted (by: { (first, second) in
  return first > second
})
```

#### 13.3.2 단축 인자 이름

스위프트는 의미없어 보이는 매개변수들의 이름을 명시하지 않고, 조금 멋스럽고 간결하게 표현할 수 있도록 단축 인자 이름을 제공한다.  단축 인자 이름은 첫 번째 전달인자부터 \$0, \$1, … 순서로 $와 숫자의 조합으로 표현한다. 단축 인자 표현을 사용하게 되면 매개변수 및 반환 타입과 실행 코드를 구분하기 위해 사용했던 키워드 in을 사용할 필요도 없어진다. 

```swift
let reversed = names.sorted {
  return $0 > $1
}
```

#### 13.3.3 암시적 반환 표현

클로저에서는 return 키워드마저 생략할 수 있다. 만약 클로저가 반환 값을 갖는 클로저이고 클로저 내부의 실행문이 단 한 줄이라면, 암시적으로 그 실행문을 반환 값으로 사용할 수 있다.

```swift
let reversed = names.sorted { $0 > $1 }
```

#### 13.3.4 연산자 함수

비교 연산자는 두 개의 피연산자를 통해 Bool 타입의 반환을 준다. sorted(by: ) 메서드에 전달한 클로저와 동일한 조건이다. 클로저는 매개변수의 타입과 반환 타입이 연산자를 구현한 함수의 모양과 동일하다면 연산자만 표기하더라도 알아서 연산하고 반환하다. 연산자는 함수로 구현되어있고, 함수는 클로저의 일종이다. 그리고 비교 연산자의 정의를 보면 전달인자로 보내기에 충분한 조건을 가지고 있다. 따라서 다음과 같이 표현할 수 있다.

```swift
let reversed = names.sorted (by: >)
```



# 13.4 값 획득

클로저는 자신이 정의된 위치의 주변 문맥을 통해 상수나 변수를 **획득**할 수 있다. 값 획득을 통해 클로저는 주변에 정의한 상수나 변수가 더 이상 존재하지 않더라도 해당 상수나 변수의 값을 자신 내부에서 참조하거나 수정할 수 있다. 

클로저는 비동기 작업에 많이 사용된다. 클로저를 통해 콜백을 작성하는 경우, 현재 상태를 미리 획득해주지 않으면, 실제로 클로저의 기능을 실행하는 순간에는 주변의 상수나 변수가 이미 메모리에 존재하지 않는 경우가 발생한다. 중첩 함수도 하나의 클로저 형태이므로 중첩 함수 주변의 변수나 상수를 획득해 놓을 수도 있다. 즉, 자신을 포함하는 함수의 지역변수나 지역상수를 획득할 수 있다.

> 클래스 인스턴스 프로퍼티로서의 클로저
>> 클래스 인스턴스의 프로퍼티로 클로저를 할당한다면 클로저는 해당 인스턴스 또는 인스턴스의 멤버의 참조를 획득할 수 있으나, 클로저와 인스턴스 사이에 강한참조 순환 문제가 발생할 수 있다. 강한참조 순환 문제는 획득 목록을 통해 없앨 수 있다. 
