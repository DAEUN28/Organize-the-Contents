# E 컴파일러 제어 구문

컴파일러 제어 구문을 사용하면 컴파일에 영향을 줄 수 있다. 스위프트에는 두 가지의 **컴파일러 제어 구문**이 있다. 하나는 **조건부 컴파일 블록**이고, 또 다른 하나는 **라인 제어 구문**이다.

### E.1 조건부 컴파일 블록

조건부 컴파일 블록에서 사용하는 키워드는 #if, #elseif, #endif 등이 있다. 조건부 컴파일 블록을 사용하면 컴파일 조건에 맞는 코드는 컴파일 단계에서 포함시키고, 그렇지 않은 코드는 컴파일하지 않는다. 

모든 조건부 컴파일 블록은 #if로 시작하여 #endif로 끝난다. #if 외에 다른 조건을 추가하고 싶다면 #elseif를 사용한다. if-else 구문과 거의 비슷한데, 다만 #endif가 마지막에 꼭 따라붙어야 하며 프로그램 실행 중에 동작하는 것이 아니라 컴파일할 때 영향을 준다. 기본적으로 조건부 컴파일 블록은 다음과 같은 형식으로 사용한다.

```swift
#if 컴파일조건1
// 컴파일 조건 1이 참이면 컴파일될 코드
#elseif 컴파일조건2
// 컴파일 조건 1이 거짓이고 컴파일 조건 2가 참이면 컴파일될 코드
#else
// 컴파일 조건 1과 컴파일 조건 2가 모두 거짓인 경우 컴파일될 코드
#endif
```

컴파일 조건은 Boolean 타입의 값이 들어갈 수 있으며, 빌드 플래그 값이 들어갈 수도 있고, 플랫폼이나 언어 버전을 체크하는 함수가 들어갈 수도 있다. 버전을 체크하는 함수 중 스위프트 버전 체크 함수인 swift() 함수의 전달인자 값을 전달할 때는 공백이 포함되면 안된다. 다음 코드처럼 사용한다.

```swift
#if os(macOS)
	print("이 프로그램은 macOS 환경을 위해 빌드했습니다.")
#elseif os(iOS)
	print("이 프로그램은 iOS 환경을 위해 빌드했습니다.")
#endif

#if swift(>=3.0)
	print("Swift 3.0과 같거나 높은 버전의 환경에서 빌드했습니다.")
#endif
```

또 한가지는 각각의 조건부 컴파일 블록 내부의 코드들은 컴파일이 되든 되지 않든 간에 문법 검사를 하는데, 예외적으로 스위프트 버전 검사를 하는 조건부 컴파일 블록 내부 코드는 문법 검사를 하지 않는다. 언어의 버전이 변경됨에 따라 변경된 문법이 컴파일 오류로 처리되지 않게 하기 위함이다.



### E.2 라인 제어 구문

**라인 제어 구문**은 라인 번호와 파일 이름을 소스 코드가 컴파일할 떄 다른 라인 번호와 파일 이름으로 사용하도록 의도적으로 변경하고 싶을 때 사용한다. 디버깅과 진단 목적에 따라 라인 제어 구문을 사용하여 디버깅 로그에 출력할 소스 코드의 위치를 변경할 수 있다. 즉, 라인 제어 구문은 파일 이름과 라인 번호를 실제 컴파일한 파일의 환경과 다르게 변경할 수 있는 기능이다. 라인 제어 구문을 통해 #file, #line의 값을 프로그래머 마음대로 변경하거나 초기화할 수 있다. 라인 제어 구문을 #sourceLocation을 사용하며, 두 가지 방법으로 사용할 수 있다.

```swift
// 이 코드처럼 사용하려면 #filerhk #line의 리터럴 표현의 값을 변경한다. 파일 이름은 문자열 값이어야 하며 라인 번호는 0 이상의 정숫값이어야 한다.
#sourceLocation(file: 파일이름, line: 라인번호)
// 이 코드를 사요하면 위 코드가 변경해 둔 #file과 #line의 값을 원래 파일에서의 위치대로 복원해준다. 위 구문이 선행된 이후에 사용해주어야 한다.
#sourceLocation()
```



# F 사용 가능 조건 확인

사용 가능 조건을 이용하면 프로그램 실행 중 동적으로 API 사용이 가능한지 판단할 수 있다. If, while, guard 등의 구문과 함께 사용할 수 있다. 사용 가능 조건은 기본적으로 다음과 같은 모양으로 사용할 수 있다.

```swift
if #available(플랫폼이름버전, ..., *) {
  // API가 사용 가능하면 실행할 코드
} else {
  // API가 사용이 불가능하면 실행할 코드
}
```

사용 가능 조건을 통해 프로그램을 실행하는 도중에 동적으로 API 사용이 가능한지 확인하여 특정 코드를 실행할 수 있도록 한다. 컴파일러는 사용가능 조건을 통해 API를 확인하여 블록 내부의 코드를 실행할 수 있을지 판단한다. 

사용 가능 조건은 플랫폼 이름과 버전의 목록 형식으로 작성한다. iOS, macOS, watchOS 등의 플랫폼 이름을 사용할 수 있으며, 버전 숫자를 포함하여 표현해준다. 애스터리스크 전달인자는 모든 플랫폼을 뜻한다. 플랫폼 조건 뒤에 마지막에는 꼭 *을 붙여주어야 한다. 사용 가능 조건은 &&, || 등의 논리연산을 통해 조건을 추가하거나 병합할 수 없다. 

사용 가능 조건을 실행 중에 확인할 수도 있지만, 프로그래머가 직접 함수, 메서드, 클래스, 구조체, 열거형 등에 사용 가능한 조건을 명시해줄 수도 있다. @available 표현을 사용하면 해당 코드 블록은 @available에 명시된 조건을 충족해야 사용할 수 있다. 또, 현재 빌드한 환경이 @available 속성과 맞지 않는다면 해당 코드 블록은 컴파일되지 않는다. 저장 프로퍼티에는 사용 가능 조건을 줄 수 없다. 



# G 속성

**속성**은 선언 또는 타입에 대한 부가 정보를 나타낸다. 스위프트에는 두 가지 종류의 속성이 있다. 하나는 선언에 부여하는 속성이고, 다른 하나는 타입에 부여하는 속성이다. 속성은 @ 표시를 속성 이름 앞에 명시한다. @ 표시 뒤에는 속성의 이름과 필요한 전달인자를 명시한다.

```swift
@ 속성이름
@ 속성이름(매개변수)
```



### G.1 선언 속성

선언 속성은 선언에만 적용할 수 있다. 선언 속성의 종류에는 available, discardableResult, objc, nonobjc, testable, objcMembers가 있다. 몇몇 선언 속성은 속성에 관한 정보를 매개변수를 통해 전달할 수 있다.

#### available

available 속성은 특정 플랫폼 또는 운영체제의 버전에 관련된 속성이다. available 속성은 매개변수가 두 개 이상 나열되는 리스트이다. 매개변수로 사용할 수 있는 플랫폼 이름은 iOS, macOS, watchOS, tvOS, swift, iOSApplicationExtension, macOSApplicationExtension, watchOSApplicationExtension, tvOSApplicationExtension, swiftApplicationExtension이다. 모든 플랫폼에 적용할 수 있도록 하려면 리스트에 애스터리스크를 적어주면 된다.

나머지 매개변수는 추가 정보를 나타내는데 쓰인다. 중요한 남김말이나 생명주기 등의 자세한 정보를 나타낼 수 있다. 그런 정보들을 나타낼 때 쓰이는 매개변수의 이름에는 unavailable, introduced, deprecated, obsoleted, message, renamed가 있다. 매개변수로 여러 플랫폼과 여러 매개변수를 동시에 전달할 수 있다. Introduced 매개변수를 생략하고 곧바로 버전을 명시해줄 수도 있다. 몇 가지 플랫폼에서 사용할 것을 한정할 때는 사용하고 싶은 플랫폼 이름과 최소 버전을 명시해주면 된다. 그리고 리스트의 맨 마지막은 꼭 애스터리스크로 끝나야 한다.

#### discardableResult

반환 값을 유의미하게 사용하지 않고 버려도 되는 함수들이 있는데, 이때 컴파일러 경고가 발생하지 않도록 하는 속성이다.

#### objc

스위프트로 선언된 코드를 Objective-C의 코드에서 표현하고 사용할 수 있도록 할 때 사용하는 속성이다. 단, 중첩 타입, 제네릭 열거형 등은 objc 속성을 사용할 수 없다.

objc 속성이 부여된 클래스는 Objective-C의 클래스를 꼭 상속받아야 한다. objc 속성이 부여된 클래스를 상속받는 클래스는 암시적으로 objc 속성이 부여된다. objc 속성이 부여된 프로토콜은 objc 속성이 부여되지 않은 스위프트의 프로토콜을 상속받을 수 없다. objc 속성이 부여된 프로토콜을 상속받는 프로토콜은 암시적으로 objc 속성이 부여된다.

#### nonobjc

Objective-C 코드에서 사용이 불가능하게 하는 속성이다. 이 속성을 부여한 메서드는 objc 속성이 부여된 메서드로 재정의할 수 없으며, objc 속성을 요구하는 프로토콜 요구사항을 충족할 수 없다.

#### testable

이 속성은 테스트를 위해 컴파일한 모듈에 정의한 내부 접근수준 정의를 공개 접근수준으로 정의한 것처럼 만들어준다. 외부에서 가져다 테스트할 수 있도록 부여할 수 있는 속성이다. 테스트를 위한 코드는 공개 접근수준과 내부 접근수준으로 testable 속성과 함께 정의한 클래스나 클래스 요소에 개방 접근수준의 접근수준처럼 접근하여 테스트할 수 있다.

#### objcMembers

클래스 선언에 이 속성을 적용하면 클래스에 objc 속성을 부여할 수 있다. 대부분의 경우 objc 속성을 사용할 테지만, 정의 하나만 Objective-C에 노출하려는 경우에는 이 속성을 사용한다. 많은 양의 정의를 노출하고자 한다면 익스텐션에 그 정의를 묶어 objc 속성을 주는 것이 좋다. 불필요한 곳에 objc 속성을 남용하면 바이너리 크기가 커질 뿐만 아니라 성능에 영향을 미칠 수도 있다.



### G.2 타입 속성

타입 속성은 타입에만 적용할 수 있다. 종류에는 autoclosure, convention, escaping이 있다.

#### autoclosure

이 속성을 부여한 매개변수에 작성된 표현을 바로 실행하지 않고 전달인자가 없는 클로저로 변경하고자 할 떄 사용한다.

#### convention

이 속성은 함수의 타입이 어떤 호출 방식을 사용할지 지정하며 swift, block, c 중 하나의 매개변수를 갖는다.

- swift : 스위프트 함수 참조를 나타낸다. 스위프트의 함수 값을 위한 표준 호출 방식이다.
- block : Objective-C의 블록 객채 참조를 나타낸다. Objective-C의 블록 객체는 C 언어 함수 호출 방식을 포함한다.
- c : C 언어 함수의 참조를 나타낸다. C 언어 함수 호출 방식이다.

C 언어 함수 호출 방식은 Objective-C 블록 호출 방식으로 사용할 수 있고, Objective-C 블록 호출 방식은 스위프트 함수 호출 방식으로 사용할 수 있다. 그러나 지역변수를 획득하지 않고 제네릭을 사용하지 않은 전역함수, 제네릭을 사용하지 않은 지역함수, 제네릭을 사용하지 않은 클로저는 C 언어 함수 호출 방식으로 사용할 수 있다.

#### escaping

이 속성을 사용하면 매개변수의 값을 나중에 실행하기 위해서 어딘가로 다시 저장될 가능성이 있다는 것을 의미하낟.



# H 타입 별칭 및 호환 타입

스위프트에서 많이 사용하는 타입이지만 실제로는 타입 별칭인 경우가 많다. 또, C 언어 등과 타입을 호환하기 위해 별칭으로 사용하는 타입들이 있다.

