# 19 타입 캐스팅

스위프트는 데이터 타입 안전을 위하여 각기 다른 타입끼리의 값 교환을 엄격히 제한한다. 또, 다른 프로그래밍 언어에서 대부분 지원하는 암시적 데이터 타입 변환을 지원하지 않는다. 



# 19.1 기존 언어의 타입 변환과 스위프트의 타입 변환

스위프트에서는 이니셜라이저의 형태로 데이터 타입의 형태를 변경한다. 즉, 기존 값을 전달인자로 받는 이니셜라이저를 통해 새로운 Int 구조체의 인스턴스를 생성한다. 스위프트에서는 이를 타입 변환 혹은 타입캐스팅이라고 칭하지 않는다. 다만 이니셜라이저를 통해 새로운 인스턴스를 생성하는 과정이다. 



# 19.2 스위프트 타입캐스팅

스위프트에서는 다른 언어의 타입 변환 혹은 타입캐스팅을 이니셜라이저로 단순화했다. 그렇다면 스위프트에는 타입캐스팅이 없다고 생각할 수 있겠지만 스위프트에도 타입캐스팅은 있으며 대신 조금 다른 의미로 사용한다. **스위프트의 타입캐스팅은 인스턴스의 타입을 확인하거나 자신을 다른 타입의 인스턴스인양 행세할 수 있는 방법으로 사용할 수 있다.** 스위프트의 타입캐스팅은 is와 as 연산자로 구현했다. 이 두 연산자로 값의 타입을 확인하거나 다른 타입으로 전환할 수 있다. 또한 타입캐스팅을 통해 프로토콜을 준수하는지도 확인해볼 수 있다. 실제로 참조 타입에서 주로 사용된다.



# 19.3 데이터 타입 확인

타입 확인 연산자인 **is**를 사용하여 인스턴스가 어떤 클래스(혹은 어떤 클래스의 자식 클래스)의 인스턴스인지 타입을 확인해볼 수 있다. 타입 확인 연산자는 인스턴스가 해당 클래스의 인스턴스거나 그 자식클래스의 인스턴스라면 true를 반환하고, 그렇지 않다면 false를 반환한다. is 연산자는 클래스의 인스턴스뿐만 아니라 모든 데이터 타입에 사용할 수 있다.

is 연산자 외에도 타입을 확인해볼 수 있는 방법은 **메타 타입 타입**을 이용하는 것이다. 메타 타입 타입은 타입의 타입을 뜻한다. 클래스 타입, 구조체 타입, 열거형 타입, 프로토콜 타입 등의 타입의 타입이다. 즉, 타입 자체가 하나의 타입으로 또 표현할 수 있다는 것이다.

클래스, 구조체, 열거형의 이름은 타입의 이름이다. 그 타입의 이름 뒤에 .Type을 붙이면 이는 메타 타입을 나타낸다. 프로토콜 타입의 메타 타입은 .Protocol이라고 붙여주면 된다. 또, self를 사용해서 타입을 값처럼 표현할 수 있다. 

```swift
protocol SomeProtocol {}
class SomeClass: SomeProtocol {}

let intType: Int.Type = Int.self
let classType: SomeClass.Type = SomeClass.self
let protocolProtocol: SomeProtocol.Protocol = SomeProtocol.self

var someType: Any.Type

someType = intType // Int
someType = classType // SomeClass
someType = protocolProtocol // SomeProtocol
```

위 코드에 정의된 SomeProtocol, SomeClass 등의 메타 타입이 하나의 값으로 취급되어 someType 변수에 할당될 수 있음을 확인할 수 있다. 또, Int도 구조체로 구현한 타입이므로 메타 타입을 값으로 취급해 할당할 수 있음을 확인할 수 있다.

만약 프로그램 실행 중에 인스턴스의 타입을 표현한 값을 알아보고자 한다면 type(of: ) 함수를 사용한다. 그래서 type(of: someInstance).self라고 표현하면 someInstance의 타입을 값으로 표현한 값을 반환한다.

> 인스턴스 self와 타입 self의 의미
>
> > .self 표현은 값 뒤에 써주면 그 값 자신을, 타입 이름 뒤에 써주면 타입을 표현하는 값을 반환한다. "stringValue".self는 "stringValue" 그 자체를, String.self는 String 타입을 나타내는 값이다.



# 19.4 다운캐스팅

**다운캐스팅** : 클래스의 상속 모식도에서 자식클래스보다 더 상위에 있는 부모클래스의 타입을 자식클래스의 타입으로 캐스팅하는 것이다. 다운캐스팅이 클래스의 인스턴스에서만 사용되는 것은 아니다. 

**타입캐스트 연산자**에는 as?와 as! 두가지가 있다. 타입캐스트 연산자를 사용하여 자식클래스 타입으로 다운캐스팅할 수 있다. 다운캐스팅은 실패의 여지가 충분히 있기 때문에 두 종류의 연산자가 있다. 

다운캐스팅을 시도해보는 **as?** : 다운캐스팅이 실패했을 경우 nil을 반환한다. 반환 타입이 옵셔널이다.

다운캐스팅을 강제하는 **as!** : 다운캐스팅에 실패할 경우 런타임 오류가 발생한다. 반환 타입이 옵셔널이 아니다.

컴파일러가 다운캐스팅을 확신할 수 있는 경우에는 as를 사용할 수도 있다. 항상 성공하는 것을 아는 경우는 캐스팅하려는 타입이 같은 타입이거나 부모클래스 타입이라는 것을 알 때이다.



> 타입캐스팅의 의미
>
> > 캐스팅은 실제로 인스턴스를 수정하거나 값을 변경하는 작업이 아니다. 인스턴스는 메모리에는 똑같이 남아있을 뿐이다. 다만 인스턴스를 사용할 때 어떤 타입으로 다루고 어떤 타입으로 접근해야 할지 판단할 수 있도록 컴퓨터에 힌트를 주는 것뿐이다. 



# 19.5 Any, AnyObject의 타입캐스팅

스위프트에는 특정 타입을 지정하지 않고 여러 타입의 값을 할당할 수 있는 Any와 AnyObject라는 특별한 타입이 있다. Any는 함수 타입을 포함한 모든 타입을 뜻하고, AnyObject는 클래스 타입만을 뜻한다.

> Any와 AnyObject를 사용하면 예기치 못한 오류가 발생할 확률이 높아지므로 되도록이면 사용을 지양하는 것이 좋다.

스위프트 표준 라이브러리에서는 Any나 AnyObject를 찾아보기 어렵지만 다른 프로그래머나 기업에서 만들어 제공하는 프레임워크의 API를 보면, Any 또는 AnyObject의 사용을 심심치 않게 볼 수 있다. API를 통해 어떤 타입의 데이터라도 전달할 수 있다는 의미로 해석해볼 수 있다. 그런데 문제는 반환되는 타입도 Any나 AnyObject라면 전달받은 데이터가 어떤 타입인지 확인하고 사용해야 한다. 왜냐하면 스위프트는 암시적 타입 변환을 허용하지 않으며, 타입에 굉장히 엄격하기 때문이다.

> 옵셔널과 Any
>
> > Any 타입은 모든 값 타입을 표현한다. 더불어 옵셔널 타입도 표현할 수 있다. 그런데도 Any 타입의 값이 들어와야 할 자리에 옵셔널 타입의 값이 위치한다면 스위프트 컴파일러는 경고를 한다. 의도적으로 옵셔널 값을 Any 타입의 값으로 사용하고자 한다면 as 연산자를 사용하여 명시적 타입 캐스팅을 해주면 경고 메시지를 받지 않는다. 