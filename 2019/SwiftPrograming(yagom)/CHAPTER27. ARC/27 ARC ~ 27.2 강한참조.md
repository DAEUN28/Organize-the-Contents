# 27 ARC

매번 전달할 때마다 값을 복사해 전달하는 값 타입과는 달리 참조 타입은 하나의 인스턴스가 참조를 통해 여러 곳에서 접근하기 때문에 언제 메모리에서 해제되는지가 중요한 문제이다. 인스턴스가 적절한 시점에 메모리에서 해제되지 않으면 한정적인 메모리 자원을 낭비하게 되며, 이는 성능의 저하로 이어지게 된다. 스위프트는 프로그램의 메모리 사용을 관리하기 위하여 메모리 관리 기법인 ARC*를 사용한다.

> ARC와 값 타입
>
> > ARC가 관리해주는 참조 횟수 계산은 참조 타입인 클래스의 인스턴스에만 적용된다. 구조체나 열거형은 값 타입이므로 참조 횟수 계산과 무관하다. 즉, 구조체나 열거형은 다른 곳에서 참조하지 않기 때문에 ARC로 관리할 필요가 없다. 

\* Automatic Reference Counting. 자동 참조 카운팅은 Objective-C에서도 사용 중이다.



# 27.1 ARC란

ARC 기능은 이름에서 알 수 있듯이 자동으로 메모리를 관리해주는 방식이다. 아무래도 프로그래머가 메모리 관리에 신경을 덜 쓸 수 있기에 편리하다. ARC는 더이상 필요하지 않은 클래스의 인스턴스를 메모리에서 해제하는 방식으로 동작한다.

ARC와 가비지 컬렉션의 가장 큰 차이는 참조를 계산하는 시점이다. ARC는 인스턴스가 언제 메모리에서 해제되어야 할지를 컴파일과 동시에 결정한다. 가비지 컬렉션은 그렇지 않다. 이 차이로 인해 생기는 장단점은 명확하다. 다음 표는 ARC와 가비지 컬렉션의 차이이다. 

| 메모리 관리 기법 | ARC                                                          | 가비지 컬렉션                                                |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 참조 카운팅 시점 | 컴파일 시                                                    | 프로그램 동작 중                                             |
| 장점             | 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어서 인스턴스가 언제 메모리에서 해제될지 예측할 수 있다. 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어서 메모리 관리를 위한 시스템 자원을 추가할 필요가 없다. | 상호 참조 상황 등의 복잡한 상황에서도 인스턴스를 해제할 수 있는 가능성이 더 높다. 특별히 규칙에 신경 쓸 필요가 없다. |
| 단점             | ARC의 작동 규칙을 모르고 사용하면 인스턴스가 메모리에서 영원히 해제되지 않을 가능성이 있다. | 프로그램 동작 외에 메모리 감시를 위한 추가 자원이 필요하므로 한정적인 자원 환경에서는 성능 저하가 발생할 수 있다. 명확한 규칙이 없기 때문에 인스턴스가 정확히 언제 메모리에서 해제될지 예측하기 어렵다. |

ARC를 이용해 자동으로 메모리 관리를 받기 위해서는 몇 가지 규칙을 알아야 한다. 왜냐하면 가비지 컬렉션과 달리 ARC는 컴파일과 동시에 인스턴스를 메모리에서 해제하는 시점이 결정하기 때문이다. 원하는 방향으로 메모리 관리가 이루어지려면 ARC에 명확한 힌트를 주어야 한다. 

클래스의 인스턴스를 생성할 때마다 ARC는 그 인스턴스에 대한 정보를 저장하기 위한 메모리 공간을 따로 또 할당한다. 그 메모리 공간에는 인스턴스의 타입 정보와 함께 그 인스턴스와 관련된 저장 프로퍼티의 값 등을 저장한다. 그 후에 인스턴스가 더 이상 필요 없는 상태가 되면 인스턴스가 차지한 메모리 공간을 다른 용도로 활용할 수 있도록 ARC가 메모리에서 인스턴스를 없앤다.

그런데 만약 아직 더 사용해야 하는 인스턴스를 메모리에서 해제시킨다면 인스턴스와 관련된 프로퍼티에 접근하거나 인스턴스의 메서드를 호출할 수 없다. 게다가 인스턴스에 강제로 접근하려고 하면 잘못된 메모리 접근으로 인해 프로그램이 강제 종료될 확률이 크다.

인스턴스가 지속해서 필요한 상황에서 ARC는 인스턴스가 메모리에서 해제되지 않도록 인스턴스 참조 여부를 계속 추적한다. 다른 인스턴스의 프로퍼티나 변수, 상수 등 어느 한 곳에서 인스턴스를 참조한다면 ARC가 해당 인스턴스를 해제하지 않고 유지해야 하는 명분이 된다. 인스턴스를 메모리에 유지시키려면 이런 명분을 ARC에 제공해야 한다.



# 27.2 강한참조

**강한참조** : 인스턴스가 계속해서 메모리에 남아있어야 하는 명분을 만들어 주는 것

인스턴스는 참조 횟수가 0이 되는 순간 메모리에서 해제되는데, 인스턴스를 다른 인스턴스의 프로퍼티나 변수, 상수 등에 할당할 때 강한참조를 사용하면 참조 횟수가 1 증가한다. 또, 강한참조를 사용하는 프로퍼티, 변수, 상수 등에 nil을 할당해주면 원래 자신에게 할당되어 있던 인스턴스의 참조 횟수가 1 감소한다.

참조의 기본은 강한참조이므로 클래스 타입의 프로퍼티, 변수, 상수 등을 선언할 떄 별도의 식별자를 명시하지 않으면 강한참조를 한다. 

#### 27.2.1 강한참조 순환 문제

그런데 복합적으로 강한참조가 일어나는 상황에서 강한참조의 규칙을 모르고 사용하게 되면 문제가 발생할 수 있다. 인스턴스끼리 서로가 서로를 강한참조할 때를 대표적인 예로 들 수 있다. 이를 **강한참조 순환**이라고 한다. 다음코드는 강한참조 순환 문제를 보여준다.

```swift
class Person {
  let name: String
  
  init(name: String) {
    self.name = name
  }
  
  var room: Room?
  
  deinit {
    print("\(name) is being deinitialized")
  }
}

class Room {
  let number: String
  
  init(number: String) {
    self.number = number
  }
  
  var host: Person?
  
  deinit {
    print("Room \(number) is being deinitialized")
  }
}

var yagom: Person? = Person(name: "yagom") // Person 인스턴스의 참조 횟수 : 1
var room: Room? = Room(number: "505")      // Room 인스턴스의 참조 횟수 : 1

room?.host = yagom // Person 인스턴스의 참조 횟수 : 2
yagom?.room = room // Room 인스턴스의 참조 횟수 : 2

yagom = nil // Person 인스턴스의 참조 횟수 : 1
room = nil  // Room 인스턴스의 참조 횟수 : 1

// Person 인스턴스를 참조할 방법 상실 - 메모리에 잔존
// Room 인스턴스를 참조할 방법 상실 - 메모리에 잔존
```

이 예제 코드를 실행했을 때 디이니셜라이저는 영원히 호출되지 않음을 확인할 수 있다. 서로 강한참조를 하는 상태에서 yagom 변수에 nil을 할당하면 yagom이 참조하던 인스턴스를  참조할 방법은 변수 room이 참조하는 인스턴스의 host 프로퍼티로 접근하는 방법밖에 남아 있지 않다. 다행히 room 변수가 아직 그 인스턴스를 강한참조로 붙들고 있기 때문에 인스턴스는 메모리에서 해제되지 않은 상황이다. 

하지만 변수 room에 nil을 할당하면, room 변수가 참조하던 인스턴스는 참조 횟수가 1 감소한다. 그렇지만 이제 yagom 변수가 참조하던 Person 클래스의 인스턴스에 접근할 방법도, room 변수가 참조하던 Room 클래스의 인스턴스에 접근할 방법도 사라진다. 참조 횟수가 0이 되지 않는 한, ARC의 규칙대로라면 인스턴스를 메모리에서 해제시키지 않기 때문에 이렇게 두 인스턴스 모두 참조 횟수 1을 남겨준 채, 메모리에 남아 있게 된다. 메모리 누수가 발생하게 되는 것이다. 디이니셜라이저가 호출되지 않은 것을 보면 메모리에서 해제되지 않고 계속 남아 있다는 것을 알 수 있다.

이렇게 두 인스턴스가 서로를 참조하는 상황에서 강한참조 순환 문제가 발생할 수 있다. 다음 코드는 강한참조 순환 문제가 발생했을 때 순환 문제를 수동으로 해결하는 방법이다. 하지만 이 방법은 만약 실수로, 아니면 깜빡하고 코드를 빼먹는다면? 아니면 해제해야 할 프로퍼티가 너무 많거나 귀찮다면? 사용하기 힘들다.

```swift
var yagom: Person? = Person(name: "yagom") // Person 인스턴스의 참조 횟수 : 1
var room: Room? = Room(number: "505") 		 // Room 인스턴스의 참조 횟수 : 1

room?.host = yagom // Person 인스턴스의 참조 횟수 : 2
yagom?.room = room // Room 인스턴스의 참조 횟수 : 2

yagom?.room = nil  // Room 인스턴스의 참조 횟수 : 1
yagom = nil        // Person 인스턴스의 참조 횟수 : 1

room?.host = nil   // Person 인스턴스의 참조 횟수 : 0
// yagom is being deinitialized

room = nil         // Room 인스턴스의 참조 횟수 : 0
// Room 505 is being deinitialized
```