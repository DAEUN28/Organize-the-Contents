# 10 프로퍼티와 메서드

**프로퍼티** : 클래스, 구조체 또는 열거형 등에 관련된 값

**메서드** : 특정 타입에 관련된 함수



# 10.1 프로퍼티

**저장 프로퍼티** : 인스턴스의 변수 또는 상수. 구조체와 클래스에서만 사용할 수 있음

**연산 프로퍼티** : 값을 저장한 것이 아니라 특정 연산을 실행한 결괏값. 클래스, 구조체, 열거형에 쓰일 수 있음

**타입 프로퍼티** : 특정 타입에 사용되는 프로퍼티

**프로퍼티 감시자** : 프로퍼티의 값이 변하는 것을 감시. 프로퍼티의 값이 변할 때 값의 변화에 따른 특정 액션을 실행. 저장 프로퍼티에 적용할 수 있으며 부모클래스로부터 상속받을 수 있음.

#### 10.1.1 저장 프로퍼티

클래스 또는 구조체의 인스턴스와 연관된 값을 저장하는 가장 단순한 개념의 프로퍼티

저장 프로퍼티를 정의할 때 프로퍼티 기본값을 지정할 수 있으며, 초기화할 때 초깃값을 지정해줄 수도 있다.

> 구조체와 클래스의 저장 프로퍼티
>>구조체의 저장 프로퍼티가 옵셔널이 아니더라도, 구조체는 저장 프로퍼티를 모두 포함하는 이니셜라이저를 자동으로 생성한다. 하지만 클래스의 저장 프로퍼티는 옵셔널이 아니라면 프로퍼티 기본값을 지정해주거나 사용자정의 이니셜라이저를 통해 반드시 초기화해주어야 한다. 또, 클래스의 인스턴스의 상수 프로퍼티는 인스턴스가 초기화될 때 한번만 값을 할당할 수 있으며, 자식클래스에서 이 초기화를 변경할 수 없다.

#### 10.1.2 지연 저장 프로퍼티

인스턴스를 생성할 때 프로퍼티에 값이 필요 없다면 프로퍼티를 옵셔널로 선언해줄 수 있다. 그런데 그것과는 조금 다른 용도로 필요할 때 값이 할당되는 지연 저장 프로퍼티가 있다. 지연 저장 프로퍼티는 호출이 있어야 값을 초기화하며, 이때 **lazy** 키워드를 사용한다. 상수는 인스턴스가 완전히 생성되기 전에 초기화해야 하므로 필요할 때 값을 할당하는 지연 저장 프로퍼티와는 맞지 않는다. 따라서 지연 저장 프로퍼티는 var 키워드를 사용하여 변수로 정의한다. 

지연 저장 프로퍼티는 주로 복잡한 클래스나 구조체를 구현할 때 많이 사용된다. 클래스 인스턴스의 저장 프로퍼티로 다른 클래스 인스턴스나 구조체 인스턴스를 할당해야 할 때가 있다. 인스턴스를 초기화하면서 저장 프로퍼티로 쓰이는 인스턴스들이 한 번에 생성되어야 하거나 굳이 모든 저장 프로퍼티를 사용할 필요가 없을 때 지연 저장 프로퍼티를 사용하면 된다. 지연 저장 프로퍼티를 잘 사용하면 불필요한 성능저하나 공간 낭비를 줄일 수 있다.

다음은 지연 저장 프로퍼티를 사용하는 방법이다.

```swift
struct CoordinatePoint {
  var x: Int = 0
  var y: Int = 0
}

class Position {
  lazy var point: CoordinatePoint = CoordinatePoint()
  let name: String
  
  init(name: String) {
    self.name = name
  }
}

let yagomPosition: Position = Position(name: "yagom")

// 이 코드를 통해 point 프로퍼티로 처음 접근할 때
// point 프로퍼티의 CoordinatePoint가 생성된다.
print(yagomPosition.point)
```

> 다중 스레드와 지연 저장 프로퍼티
>> 다중 스레드 환경에서 지연 저장 프로퍼티에 동시다발적으로 접근할 때는 한 번만 초기화된다는 보장이 없다. 생성되지 않은 지연 저장 프로퍼티에 많은 스레드가 비슷한 시점에 접근한다면 여러 번 초기화될 수 있다.

#### 10.1.3 연산 프로퍼티

연산 프로퍼티는 실제 값을 저장하는 프로퍼티가 아니라, 특정 상태에 따른 값을 연산하는 프로퍼티이다. 인스턴스 내/외부의 값을 연산하여 적절한 값을 돌려주는 접근자의 역할이나 은닉화된 내부의 프로퍼티 값을 간접적으로 설정하는 설정자의 역할을 할 수도 있다.

메서드를 두고 연산 프로퍼티를 쓰는 이유는 다음과 같다. 인스턴스 외부에서 메서드를 통해 인스턴스 내부 값에 접근하려면 메서드를 두 개 구현해야 한다. 또한 이를 감수하고 메서드로 구현한다 해도 두 메서드가 분산 구현되어 코드의 가독성이 나빠질 위험이 있다. 타인의 코드를 보는 프로그래머의 입장에서는 프로퍼티가 메서드 형식보다 훨씬 더 간편하고 직관적이기도 하다. 다만 연산 프로퍼티는 접근자인 get 메서드만 구현해둔 것처럼 읽기 전용 상태로 구현하기 쉽지만, 쓰기 전용 상태로 구현할 수 없다는 단점이 있다. 메서드로는 설정자 메서드만 구현하여 쓰기 전용 상태로 구현할 수 있지만 연산 프로퍼티는 그것이 불가능하다. 

연산 프로퍼티를 사용하면 하나의 프로퍼티에 접근자와 설정자가 모두 모여있고, 해당 프로퍼티가 어떤 역할을 하는지 좀 더 명확하게 표현 가능하다. 

설정자의 매개변수로 원하는 이름을 소괄호 안에 명시해주면 set 메서드 내부에서 전달받은 전달인자를 사용할 수 있다. 관용적인 표현으로 newValue로 매개변수 이름을 대신할 수 있다. 그럴 경우에는 매개변수를 따로 표기하지 말아야 한다. 또, 굳이 설정자가 필요없다면 읽기 전용으로 연산 프로퍼티를 사용할 수도 있다. 연산 프로퍼티를 읽기 전용으로 구현하려면 get 메서드만 사용하면 된다.

#### 10.1.4 프로퍼티 감시자

프로퍼티 감시자를 사용하면 프로퍼티의 값이 변경됨에 따라 적절한 액션을 취할 수 있다. 프로퍼티 감시자는 프로퍼티의 값이 새로 할당될 때마다 호출한다. 이때 변경되는 값이 현재의 값과 같더라도 호출한다.

프로퍼티 감시자는 지연 저장 프로퍼티에 사용할 수 없으며 오로지 일반 저장 프로퍼티에만 적용할 수 있다. 또한 프로퍼티 재정의를 통해 상속받은 저장 프로퍼티 또는 연산 프로퍼티에도 적용할 수 있다. 물론 상속받지 않은 연산 프로퍼티에는 프로퍼티 감시자를 사용할 필요가 없으며 할 수도 없다. 연산 프로퍼티의 접근자와 설정자를 통해 프로퍼티 감시자를 구현할 수 있기 때문이다. 연산 프로퍼티는 상속 받았을 때만 프로퍼티 재정의를 통해 프로퍼티 감시자를 사용한다. 상속받은 연산 프로퍼티를 재정의해도 기존의 연산 프로퍼티 기능은 동작한다.

프로퍼티 감시자에는 프로퍼티의 값이 변경되기 직전에 호출하는 **willSet** 메서드와 프로퍼티의 값이 변경된 직후에 호출하는 **didSet** 메서드가 있다. willSet 메서드와 didSet 메서드에는 매개변수가 하나씩 있다. 매개변수의 이름을 따로 지정하지 않으면 willSet 메서드에는 newValue, didSet 메서드에는 oldValue라는 매개변수 이름이 자동 지정된다. 

willSet 메서드에 전달되는 전달인자 : 프로퍼티가 변경될 값

didSet 메서드에 전달되는 전달인자 : 프로퍼티가 변경되기 전의 값

다음 예제의 주석의 흐름을 통해 언제 어떤 메서드가 호출되는지 알 수 있다.

```swift
class Account {
  var credit: Int = 0 { // 저장 프로퍼티
    willSet {
      print("잔액이 \(credit)원에서 \(newValue)원으로 변경될 예정입니다.")
    }
    
    didSet {
      print("잔액이 \(oldValue)원에서 \(credit)원으로 변경되었습니다.")
    }
  }
  
  var dollarValue: Double { // 연산 프로퍼티
    get {
      return Double(credit) / 1000.0
    }
    
    set {
      credit = Int(newValue * 1000)
      print("잔액을 \(newValue)원으로 변경 중입니다.")
    }
  }
}

class ForeignAccount: Account {
  override var dollarValue: Double {
    willSet {
      print("잔액이 \(dollarValue)달러에서 \(newValue)달러으로 변경될 예정입니다.")
    }
    
    didSet {
      print("잔액이 \(oldValue)달러에서 \(dollarValue)달러으로 변경되었습니다.")
    }
  }
}

let myAccount: ForeignAcount = ForeignAccount()
myAccount.credit = 1000
// 잔액이 0원에서 1000원으로 변경되었습니다.

// 잔액이 1.0달러에서 2.0달러로 변경될 예정입니다.
// 잔액이 1000원에서 2000원으로 변경될 예정입니다.
// 잔액이 1000원에서 2000원으로 변경되었습니다.

myAccount.dollarValue = 2 // 잔액을 2.0달러로 변경 중입니다.
// 잔액이 1.0달러에서 2.0달러로 변경되었습니다.
```

> 입출력 매개변수와 프로퍼티 감시자
>> 만약 프로퍼티 감시자가 있는 프로퍼티를 함수의 입출력 매개변수의 전달인자로 전달한다면 항상 willSet과 didSet 감시자를 호출한다. 함수 내부에서 값이 변경되는 되지 않든 간에 함수가 종료되는 시점에 값을 다시 쓰기 때문이다.



#### 10.1.5 전역변수와 지역변수

연산 프로퍼티와 프로퍼티 감시자는 전역변수와 지역변수 모두에 사용할 수 있다. 따라서 프로퍼티에 한정하지 않고, 전역에서 쓰일 수 있는 변수와 상수에도 두 기능으로 사용할 수 있다. 함수나 메서드, 클로저, 클래스, 구조체, 열거형 등의 범위 안에 포함되지 않았던 변수나 상수는 모두 전역변수 또는 전역상수에 해당된다. 전역변수 또는 지역변수는 저장변수라고 할 수 있다. 저장변수는 마치 저장 프로퍼티처럼 값을 저장하는 역할을 한다. 그런데 전역변수나 지역변수를 연산변수로 구현할 수도 있으며, 프로퍼티 감시자를 구현할 수도 있다. 전역변수 또는 전역상수는 지연 저장 프로퍼티처럼 처음 접근할 때 최초로 연산이 이루어진다. lazy 키워드를 사용하여 연산을 늦출 필요가 없다. 반대로 지역변수 및 지역상수는 절대로 지연 연산 되지 않는다. 

#### 10.1.6 타입 프로퍼티

각각의 인스턴스가 아닌 타입 자체에 속하는 프로퍼티

타입 자체에 영향을 미친다. 인스턴스의 생성 여부와 상관없이 타입 프로퍼티의 값은 하나며, 그 타입의 모든 인스턴스가 공통으로 사용하는 값, 모든 인스턴스에서 공용으로 접근하고 값을 변경할 수 있는 변수 등을 정의할 때 유용하다. 타입 프로퍼티는 두가지 인데 저장 타입 프로퍼티는 변수 또는 상수로 선언할 수 있으며, 연산타입 프로퍼티는 변수로만 선언할 수 있다. 저장 타입 프로퍼티는 반드시 초깃값을 설정해야 하며 지연 연산된다. 지연 저장 프로퍼티와는 조금 다르게 다중 스레드 환경이라고 하더라도 단 한 번만 초기화된다는 보장을 받는다. 지연 연산 된다고 해서 lazy 키워드로 표시하지는 않는다.

인스턴스를 생성하지 않고도 사용할 수 있으며 타입에 해당하는 값이다. 그래서 인스턴스에 접근할 필요 없이 타입 이름만으로도 프로퍼티를 사용할 수 있다.

#### 10.1.7 키 경로

프로퍼티는 값을 바로 꺼내오는 것이 아니라 함수처럼 어떤 프로퍼티의 위치만 참조하도록 할 수 있다. 키 경로를 사용하면 간접적으로 특정 타입의 어떤 프로퍼티 값을 가리켜야 할지 미리 지정해두고 사용할 수 있다. 키 경로 타입은 AnyKeyPath라는 클래스로부터 파생된다. 기존의 키 경로에 하위 경로를 덧붙여 줄수도 있다. 또, 각 인스턴스의 KeyPath 서브스크립트 메서드에 키 경로를 전달하여 프로퍼티에 접근할 수 있다.

WritableKeyPath<Root, Value> : 값 타입에 키 경로 타입으로 읽고 쓸 수 있는 경우에 적용

ReferenceWritableKeyPath<Root, Value> : 참조타입, 즉 클래스 타입에 키 경로 타입으로 읽고 쓸 수 있는 경우에 적용된다.

다음은 키 경로는 역슬래시와 타입, 마침표, 경로로 구성되고 경로는 프로퍼티 이름이라고 생각하면 된다.

```swift
타입이름.경로.경로.경로
```

상수로 지정한 값 타입과 읽기 전용 프로퍼티는 키 경로 서브스크립트로도 값을 바꿔줄 수 없다. 키 경로를 잘 활용하면 프로토콜과 마찬가지로 타입 간의 의존성을 낮추는데 많은 도움을 준다. 또, 애플의 프레임워크는 키-값 코딩 등 많은 곳에 키 경로를 활용한다.

> 접근수준과 키 경로
>> 키 경로는 타입 외부로 공개된 인스턴스 프로퍼티에 한하여 표현할 수 있다.
