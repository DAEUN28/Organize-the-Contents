# 2. 스위프트 기본 데이터 구조의 활용

> 애플이 구조체를 사용하는 이유
>
> > 스위프트에 정의된 타입 대부분은 구조체이다. 그리고 스위프트에서 값 타입인 구조체를 사용해 참조 타입을 지원하도록 한 이유는 상속, 초기화 해제객체, 참조 카운팅 등을 다양한 기능을 제공하는 클래스에 비해 훨씬 제한된 수의 기능을 제공하는 스위프트가 표준 라이브러리의 구성 요소로서 적합하기 때문이다. 
> >
> > 또한 구조체는 값 타입으로서, 단 하나의 소유 객체만을 지니며, 새로운 변수에 할당하거나 함수에 전달할 때는 항상 복사해서 사용한다는 점도 중요한 이유다. 구조체의 이런 단순성이 우리가 작성한 코드를 체계적으로 안정화시키며, 특정 구조체를 변경해도 애플리케이션의 다른 부분은 이에 영향을 받지 않을 수 있다.



## 스위프트에서 배열 선언

스위프트에는 다음과 같은 세 가지 유형의 배열이 있다.

- Array
- ContiguousArray
- ArraySlice



모든 Array 클래스는 배열에 포함된 배열 요소를 저장하기 위한 메모리 공간을 유지한다. 배열 요소의 타입이 클래스 또는 @objc 프로토콜 타입이 아닌 경우, 배열의 메모리 영역은 인접 블록에 저장된다. 이와 달리, 배열 요소의 타입이 클래스 또는 @objc 클래스 타입인 경우, 배열의 메모리 영역은 인접 블록에 NSArray의 인스턴스 또는 NSArray의 서브클래스의 인스턴스로 저장된다.

저장하려는 배열 요소가 클래스 또는 @objc 프로토콜인 경우, ContaguousArray유형을 사용하면 좀 더 효율적인 코드를 작성할 수 있다. ContiguousArray 유형을 사용하면 좀 더 효율적인 코드를 작성할 수 있다. ContiguousArray 클래스는 Array 구현에 사용되는 다양한 프로토콜을 공유할 수 있으며, 거의 비슷한 프로퍼티를 활용할 수 있다. ContiguousArray가 Array 클래스와 다른 점은 오브젝티브C와의 브릿징을 지원하지 않는다는 것이다.

ArraySlice 클래스는 Array, ContiguousArray 혹은 다른 ArraySlice의 속성을 그대로 지닌다. ArraySlice 역시 배열요소를 저장할 때 인접 메모리 공간을 사용하며, 오브젝티브C와의 브릿징을 지원하지 않는다. ArraySlice의 가장 큰 특징은 이미 존재하는 또 다른 배열 타입의 일부 그룹을 대표한다는 것이다. 바로 이때문에 원본인 배열의 생애주기가 끝나면 ArraySlice에 저장된 배열 요소 역시 접근 불가능 상태가 된다는 점에 주의해야 한다. **따라서 애플은 ArraySlice 인스턴스를 장시간 유지하지 말도록 권장하고 있다.**

스위프트배열은 기하급수적 증가 전략을 따르며, 배열에 요소가 추가될 때마다 소진된 배열 용량을 자동으로 증가시킨다. 배열 요소 추가 작업을 여러 차례 나눠서 반복적으로 진행할 경우, 각각의 추가 작업에는 일정한 시간이 소요된다. 만일 배열에 대량의 요소가 추가될 것임을 알 수 있는 경우, 추가적인 배열 용량을 미리 할당해 두는 편이 좋다. 

```swift
var intArray = [Int]()
intArray.capacity 						// 0개 요소를 포함
intArray.reserveCapacity(500)
intArray.capacity							// 508개 요소를 포함
```

위 예제의 실행 결과를 보면 500개의 용량을 예약했지만 실제 할당된 공간은 그보다 크다는 사실을 알 수 있다. 이는 스위프트가 실행 성능을 고려해서 실제 요청한 양 이상을 할당한 것으로 볼 수 있으며, 최소한 예약한 배열 용량만큼은 확보할 수 있음을 알 수 있다.





## 마이클 패더스가 주창한 SOLID원칙

SOLID는 객체지향 디자인과 프로그래밍을 설명하기 위한 다섯가지 원칙으로 다음과 같은 내용을 담고 있다.

- **단일 책임 원칙** : 하나의 클래스는 오직 단 하나의 책임만 부담해야 한다.
- **개방과 폐쇄의 원칙** : 소프트웨어는 확장이라는 측면에서는 개방돼 있어야 하고, 수정이라는 측면에서는 폐쇄돼 있어야 한다.
- **리스코프 대체 원칙** : 특정 클래스에서 분화돼 나온 클래스는 원본 클래스로 대체 가능해야 한다.
- **인터페이스 세분화 원칙** : 개별적인 목적에 대응할 수 있는 여러 개의 인터페이스가 일반적인 목적에 대응할 수 있는 하나의 인터페이스보다 낫다.
- **의존성 도치의 원칙** : 구체화가 아닌 추상화를 중시한다.







