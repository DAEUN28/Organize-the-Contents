# 14.1 옵셔널 체이닝

**옵셔널 체이닝** : 옵셔널에 속해 있는 nil일지도 모르는 프로퍼티, 메서드, 서브스크립션 등을 가져오거나 호출할 때 사용할 수 있는 일련의 과정

옵셔널에 값이 있다면 프로퍼티, 메서드, 서브스크립트 등을 호출할 수 있고, 옵셔널이 nil이라면 프로퍼티, 메서드, 서브스크립트 등은 nil을 반환한다. 즉, 옵셔널을 반복 사용하여 옵셔널이 자전거 체인처럼 서로 꼬리를 물고 있는 모양이기 때문에 옵셔널 체이닝이라고 부른다. 자전거 체인에서 한 칸이라도 없거나 고장 나면 체인 전체가 동작하지 않듯이 중첩된 옵셔널 중 하나라도 값이 존재하지 않는다면 결과적으로 nil을 반환한다. 

옵셔널 체이닝은 프로퍼티나 메서드 또는 서브스크립트를 호출하고 싶은 옵셔널 변수나 상수 뒤에 물음표를 붙여 표현한다. 옵셔널체이닝은 항상 nil이 반환될 가능성이 있으므로 옵셔널 체이닝의 반환된 값은 항상 옵셔널이다. 따라서 옵셔널 체이닝은 옵셔널 바인딩과 결합할 수 있다. 또, 옵셔널 체이닝을 통해 값을 받아오는 것 뿐만 아니라 반대로 값을 할당해줄 수도 있다. 

\+ 느낌표 

물음표 대신에 느낌표를 사용할 수도 있는데 이는 옵셔널에서 값을 강제 추출하는 효과가 있다. 물음표를 사용하는 것과 가장 큰 차이점은 값을 강제 추출하기 때문에 옵셔널에 값이 없다면 런타임 오류가 발생한다는 것이다. 또 다른 점은 옵셔널에서 값을 강제 추출해 반환하기 때문에 반환 값이 옵셔널이 아니라는 점이다. 하지만 정말 nil이 아니라는 확신을 하더라도 사용을 지양하는 편이 좋다. 

옵셔널 체이닝을 통해 메서드와 서브스크립트 호출도 가능하다. 서브스크립트는 인덱스를 통해 값을 넣고 빼올 수 있는 기능이다.먼저, 옵셔널 체이닝을 통한 메서드 호출 방법은 프로퍼티 호출과 동일하다. 옵셔널의 서브스크립트를 사용하고자 할 때는 대괄호보다 앞에 물음표를 표기해주어야 한다. 이는 서브스크립트 외에도 언제나 옵셔널 체이닝을 사용할 때의 규칙이다. 



# 14.2 빠른종료

**빠른종료**의 핵심 키워드는 **guard**이다. guard 구문은 if 구문과 유사하게 Bool 타입의 값으로 동작하는 기능이다. guard 뒤에 따라 붙는 코드의 실행 결과가 true일 때 코드가 계속 실행된다. if 구문과는 다르게 guard 구문은 항상 else 구문이 뒤에 따라와야 한다. 만약 guard 뒤에 따라오는 Bool 값이 false라면 else의 블록 내부 코드를 실행하게 되는데, 이때 else 구분의 블록 내부에는 꼭 자신보다 상위의 코드 블록을 종료하는 코드가 들어가게된다. 그래서 특정 조건에 부합하지 않다는 판단이 되면 재빠르게 코드 블록의 실행을 종료할 수 있다. 이렇게 현재의 코드 블록을 종료할 때는 return, break, continue, throw등의 제어문 전환 명령을 사용한다. 또는 fatalError() 와 같은 비반환 함수나 메서드를 호출할 수도 있다. 

```swift
guard Bool타입값 else {
  예외사항 실행문
  제어문 전환 명령어
}
```

guard 구문을 사용하면 if 코드를 훨씬 간결하고 읽기 좋게 구성할 수 있다. if 구문을 사용하면 예외사항을 else 블록으로 처리해야 하지만 예외사항만을 처리하고 싶다면 guard 구문을 사용하는 것이 훨씬 간편하다.

Bool 타입의 값으로 guard 구문을 동작시킬 수 있지만 옵셔널 바인딩의 역할도 할 수 있다. guard 뒤에 따라오는 옵셔널 바인딩 표현에서 옵셔널의 값이 있는 상태라면 guard 구문에서 옵셔널 바인딩된 상수를 guard 구문이 실행된 아래 코드부터 함수 내부의 지역상수처럼 사용할 수 있다. 

조금 더 구체적인 조건을 추가하고 싶다면 쉼표로 추가조건을 나열해주면 된다. 추가된 조건은 Bool 타입 값이어야 한다. 쉼표를 &&로 치환해도 같은 결과를 얻을 수 있다. 

guard 구문의 한계는 자신을 감싸는 코드 블록의 제어문 전환 명령어를 쓸 수 없는 상황이라면 사용이 불가능하다는 점이다. 함수나 메서드, 반복문 등 특정 블록 내부에 위치하지 않는다면 사용이 제한된다.