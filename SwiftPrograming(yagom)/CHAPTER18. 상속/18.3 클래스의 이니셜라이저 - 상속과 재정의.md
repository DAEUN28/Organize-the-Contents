# 18.3 클래스의 이니셜라이저 - 상속과 재정의

#### 18.3.1 지정 이니셜라이저와 편의 이니셜라이저

**지정 이니셜라이저**는 필요에 따라 부모클래스의 이니셜라이저를 호출할 수 있으며, 이니셜라이저가 정의된 클래스의 모든 프로퍼티를 초기화해야 하는 임무를 갖고 있다. 지정 이니셜라이저는 클래스의 이니셜라이저 중 기둥과 같은 역할을 하므로 클래스에 하나 이상 정의한다. 물론 여러 개를 정의할 수 있지만 편의 이니셜라이저에 비하면 적다. 

모든 클래스는 하나 이상의 지정 이니셜라이저를 갖는다. 만약 조상클래스에서 지정 이니셜라이저가 자손클래스의 지정 이니셜라이저 역할을 충분히 할 수 있다면, 자손클래스는 지정 이니셜라이저를 갖지 않을 수도 있다. 아마도 이런 경우는 조상클래스로부터 물려받은 프로퍼티를 제외하고 옵셔널 저장 프로퍼티 외에 다른 저장 프로퍼티가 없을 가능성이 크다. 다음은 지정 이니셜라이저 정의 형식이다.

```swift
init(매개변수들) {
  초기화 구문
}
```

**편의 이니셜라이저**는 초기화를 좀 더 쉽게 도와주는 역할을 한다. 편의 이니셜라이저는 지정 이니셜라이저를 자신 내부에서 호출한다. 지정 이니셜라이저의 매개변수가 많아 외부에서 일일이 전달인자를 전달하기 어렵거나 특정 목적에 사용하기 위해서 편의 이니셜라이저를 설계할 수도 있다. 편의 이니셜라이저는 필수 요소는 아니지만 클래스 설계자의 의도대로 외부에서 사용하길 원하거나 인스턴스 생성 코드를 작성하는 수고를 덜 때 유용하게 사용할 수 있다.

```swift
convenience init(매개변수들) {
  초기화 구문
}
```

#### 18.3.2 클래스의 초기화 위임

지정 이니셜라이저와 편의 이니셜라이저 사이의 관계를 간단히 정리하기 위해 세 가지 규칙을 적용할 수 있다.

1. 자식클래스의 지정 이니셜라이저는 부모클래스의 지정 이니셜라이저를 반드시 호출해야 한다.
2. 편의 이니셜라이저는 자신을 정의한 클래스의 다른 이니셜라이저를 반드시 호출해야 한다.
3. 편의 이니셜라이저는 궁극적으로는 지정 이니셜라이저를 반드시 호출해야 한다.

#### 18.3.3 2단계 초기화

스위프트의 2단계 초기화는 프로퍼티를 초기화하기 전에 프로퍼티 값에 접근하는 것을 막아 초기화를 안전하게 할 수 있도록 해준다. 또, 다른 이니셜라이저가 프로퍼티의 값을 실수로 변경하는 것을 방지할 수도 있다. 스위프트 컴파일러는 2단계 초기화를 오류 없이 처리하기 위해 다음과 같은 네 가지 안전확인을 실행한다.

1. 자식클래스의 지정 이니셜라이저가 부모클래스의 이니셜라이저를 호출하기 전에 자신의 프로퍼티를 모두 초기화했는지 확인한다. 
2. 자식클래스의 지정 이니셜라이저는 상속받은 프로퍼티에 값을 할당하기 전에 반드시 부모클래스의 이니셜라이저를 호출해야 한다.
3. 편의 이니셜라이저는 자신의 클래스에 정의한 프로퍼티를 포함하여 그 어떤 프로퍼티라도 값을 할당하기 전에 다른 이니셜라이저를 호출해야 한다.
4. 초기화 1단계를 마치기 전까지 이니셜라이저는 인스턴스 메서드를 호출할 수 없다. 또, 인스턴스 프로퍼티의 값을 읽어들일 수도 없다. self 프로퍼티를 자신의 인스턴스로 나타내는 값으로 활용할 수도 없다.

클래스의 인스턴스는 초기화 1단계를 마치기 전까지는 아직 유효하지 않다. 프로퍼티는 읽기만 가능하며, 메서드는 호출될 수 있을 뿐이다. 클래스의 인스턴스가 초기화 1단계를 마쳤을 떄 비로소 유효한 인스턴스가 되는 것이다. 

> 1단계

1. 클래스가 지정 또는 편의 이니셜라이저를 호출한다.
2. 그 클래스의 새로운 인스턴스를 위한 메모리가 할당된다. 메모리는 아직 초기화되지 않은 상태이다.
3. 지정 이니셜라이저는 클래스에 정의된 모든 저장 프로퍼티에 값이 있는지 확인한다. 현재 클래스 부분까지의 저장 프로퍼티를 위한 메모리는 이제 초기화되었다.
4. 지정 이니셜라이저는 부모클래스의 이니셜라이저가 같은 동작을 행할 수 있도록 초기화를 양도한다. 
5. 부모클래스는 상속 체인을 따라 최상위 클래스에 도달할 떄까지 이 작업을 반복한다. 

최상위 클래스에 도달했을 떄, 최상위 클래스까지의 모든 저장 프로퍼티에 값이 있다고 확인하면 해당 인스턴스의 메모리는 모두 초기화된 것이다. 이로써 1단계가 완료된다.

> 2단계

1. 최상위 클래스로부터 최하위 클래스까지 상속 체인을 따라 내려오면서 지정 이니셜라이저들이 인스턴스를 제 각각 사용자정의하게 된다. 이 단계에서는 self를 통해 프로퍼티 값을 수정할 수 있고, 인스턴스 메서드를 호출하는 등의 작업을 진행할 수 있다.
2. 마지막으로 각각의 편의 이니셜라이저를 통해 self를 통한 사용자정의 작업을 진행할 수 있다.

#### 18.3.4 이니셜라이저 상속 및 재정의

기본적으로 스위프트의 이니셜라이저는 부모클래스의 이니셜라이저를 상속받지 않는다. 부모클래스로부터 물려받은 이니셜라이저는 자식클래스에 최적화되어 있지 않아서, 부모클래스의 이니셜라이저를 사용했을 때 자식클래스의 새로운 인스턴스가 완전하고 정확하게 초기화되지 않는 상황을 방지하고자 함이다. 안전하고 적절하다고 판단되는 특정한 상황에서는 부모클래스의 이니셜라이저가 상속되기도 한다.

보통 부모클래스의 이니셜라이저와 똑같은 이니셜라이저를 자식클래스에서 사용하고 싶다면 자식클래스에서 부모의 이니셜라이저와 똑같은 이니셜라이저를 구현해주면 된다.

부모클래스와 동일한 지정 이니셜라이저를 자식클래스에서 구현해주려면 재정의하면 된다. 그러려면 override 수식어를 붙여야 한다. 클래스에 주어지는 기본 이니셜라이저를 재정의할 때도 마찬가지이다. 자식클래스의 편의 이니셜라이저가 부모클래스의 지정 이니셜라이저를 재정의하는 경우에도 override 수식어를 붙여준다. 

반대로 부모클래스의 편의 이니셜라이저와 동일한 이니셜라이저를 자식클래스에 구현할 떄는 override 수식어를 붙이지 않는다. 자식클래스에서 부모클래스의 편의 이니셜라이저는 절대로 호출할 수 없기 때문이다. 즉, 재정의할 필요가 없다.