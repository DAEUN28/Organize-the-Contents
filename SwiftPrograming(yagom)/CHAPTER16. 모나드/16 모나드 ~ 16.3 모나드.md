# 16 모나드

모나드는 특정한 상태로 값을 포장하는 것에서 출발한다. 스위프트에서는 이를 옵셔널이라는 형태로 구현했는데 값이 있을지 없을지 모르는 상태 속에 포장하는 것이다. 스위프트의 옵셔널은 스위프트에서 모나드를 이해하기 좋은 예 중 하나이다. 함수객체와 모나드는 특정 기능이 아닌 디자인 패턴 혹은 자료구조라고 할 수 있다.



# 16.1 컨텍스트

컨텍스트의 사전적 정의는 '맥락', '전후 사정'등이다. 하지만 여기서 말하는 컨텍스트는 '콘텐츠를 담은 그 무엇인가'를 뜻한다. 즉, 물컵에 물이 담겨있으면 물은 콘텐츠고 물컵은 컨텍스트라고 볼 수 있다. 옵셔널은 some과 none이라는 두가지의 컨텍스트를 갖는다. 



# 16.2 함수객체

맵은 컨테이너의 값을 변형시킬 수 있는 고차함수이다. 그리고 옵셔널은 컨테이너와 같은 역할을 하기 때문에 맵 함수를 사용할 수 있다. 

**함수객체**란 맵을 적용할 수 있는 컨테이너 타입이라고 말할 수 있다. 그리고 Array, Dictionary, Set 등등 스위프트의 많은 컬렉션 타입이 함수객체이다. 다음은 옵셔널의 map 메서드 구현이다.

```swift
extension Optional {
  func map<U>(_ transform: (Wrapped) -> U) -> U?{
    switch self {
        case .some(let value): return transform(value)
        case .none: return .none
    }
	}
}
```

옵셔널의 map 메서드를 호출하는 과정은 다음과 같다.

- 컨텍스트에 값이 있을 때
  1. 컨텍스트로부터 값 추출
  2. 전달받은 함수 적용
  3. 결괏값을 다시 컨텍스트에 담아 반환
- 컨텍스트의 값이 없을 때
  1. 컨텍스트에 값이 없음
  2. 함수 적용 안함
  3. 결과적으로 아무것도 하지 않음

컨텍스트에 값이 없다면 빈 컨텍스트로 다시 반환한다. 



# 16.3 모나드

**모나드**는 함수객체의 일종으로 맵 함수를 적용할 수 있는, 즉 맵 함수를 지원하는 컨테이너 타입이다. 모나드는 거기에 더 나아가 값이 있을지 없을지 모르는 상태를 추가한다. 즉, 모나드는 값이 있을 수도 있고 없을 수도 있는 컨텍스트를 갖는 함수객체 타입이다.

함수객체는 포장된 값에 함수를 적용할 수 있었다. 그래서 모나드도 컨텍스트에 포장된 값을 처리하여 포장된 값을 컨텍스트에 다시 반환하는 함수를 적용할 수 있다. 이와 같은 기능을 수행하는 **플랫맵**이라는 메서드가 있다. 플랫맵은 포장된 값을 받아서 값이 있으면 포장을 풀어서 값을 처리한 후 포장된 값을 반환하고, 값이 없으면 없는 대로 다시 포장하여 반환한다.

맵과 같이 플랫맵도 함수를 매개변수로 받고, 옵셔널은 모나드이므로 플랫맵을 사용할 수 있다. 옵셔널의 플랫맵의 동작은 다음과 같다. 

- 컨텍스트에 값이 있을 때
  1. 컨텍스트로부터 값 추출
  2. 추출한 값을 함수에 전달
  3. 함수를 실행
  4. 결괏값을 다시 컨텍스트에 담아 반환
- 컨텍스트의 값이 없을 때
  1. 컨텍스트에 값이 없음
  2. 아무것도 하지 않음
  3. 빈 컨텍스트 반환

플랫맵과 맵의 차이점은 내부의 값을 알아서 더 추출해준다는 것이다. 플랫맵은 내부에 포장된 값도 추출해낼 수 있다. 다음 코드를 통해 차이를 알 수 있다.

```swift
let optionalArr: [Int?] = [1,2,nil,5]

let mappedArr: [Int?] = optionalArr.map{ $0 } //[Optional(1), Optional(2), nil, Optional(5)]
let flatmappedArr: [Int?] = optionalArr.flatMap{ $0 } // [1,2,5]
```

컨테이너 내부에 또 다른 컨테이너들이 여러개 들어가 있을 때, 맵 메서드를 사용한 결과는 Array 컨테이너 내부의 값 타입이나 형태가 어찌 되었든, Array 내부에 값이 있으면 그 값을 그저 클로저의 코드에서만 실행하고 결과를 다시 Array 컨테이너에 담기만 한다. 그러나 플랫맵을 통해 클로저를 실행하면 알아서 내부 컨테이너까지 값을 추출한다. 

플랫맵은 내부의 값을 1차원적으로 펼쳐놓는 작업도 하기 때문에, 값을 꺼내어 모두 동일한 위상으로 펼쳐놓는 모양새를 갖출 수 있다. 그래서 값을 일자로 평평하게 펼친다고 해서 플랫맵으로 불리는 것이다.

플랫맵을 사용하여 체인을 연결했을 때 결과는 옵셔널 타입이다. 그러나 맵을 사용하여 체인을 연결하면 옵셔널의 옵셔널 형태로 반환된다. 그 이유는 플랫맵은 함수의 결괏값에 값이 있다면 추출해서 평평하게 만드는 과정을 내포하고, 맵은 그렇지 않기 때문이다. 맵은 옵셔널 타입의 값을 옵셔널이라는 컨테이너 안에 다시 집어넣어 반환하고, 플랫맵은 추출 작업을 통해 옵셔널에서 꺼내온 값을 다시 옵셔널에 넣어주기 때문에 연쇄 연산이 가능하다. 옵셔널과 맵과 플랫맵 정의를 보면 더욱 명확하게 알 수 있다. 

```swift
func map<U>(_ transform: (Wrapped) throws -> U) rethrows -> U?
func flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U?
```

String 타입을 전달받고 Int? 타입을 반환하는 함수를 맵에 전달하면 U == Int?가 된다. 따라서 최종 반환 타입은 Int??가 된다. 하지만 똑같은 함수를 플랫맵에 전달하면 U? == Int?가 된다. 즉 U == Int가 되기 때문에 플랫맵의 동작 결과는 최종적으로 Int? 타입을 반환하게 된다. 

플랫맵은 체이닝 중간에, 연산에 실패하는 경우나 값이 없어지는 경우 (.none이 된다거나 nil이 된다는 등) 이외에는 별도의 예외 처리없이 빈 컨테이너를 반환한다. nil이 반환된 부분 이후에 호출되는 메서드는 무시한다. 이는 옵셔널 체이닝과 완전히 같은 동작이다. 바로 옵셔널이 모나드이기 때문에 가능한 것이다. 